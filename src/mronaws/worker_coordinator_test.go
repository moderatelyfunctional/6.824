package mronaws

import "fmt"
import "testing"

import "time"

import "strings"
import "strconv"
import "unicode"

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
func CountMap(filename string, contents string) []KeyValue {
	// function to detect word separators.
	ff := func(r rune) bool { return !unicode.IsLetter(r) }

	// split contents into an array of words.
	words := strings.FieldsFunc(contents, ff)

	kva := []KeyValue{}
	for _, w := range words {
		kv := KeyValue{w, "1"}
		kva = append(kva, kv)
	}
	return kva
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
func CountReduce(key string, values []string) string {
	// return the number of occurrences of this word.
	return strconv.Itoa(len(values))
}

func buildIntermediateFiles(testCoordinatorInput TestCoordinatorInput) []string {
	intermediateFiles := []string{}
	for i := 0; i < len(testCoordinatorInput.files); i++ {
		for j := 0; j < testCoordinatorInput.nReduce; j++ {
			intermediateFiles = append(
				intermediateFiles,
				fmt.Sprintf("%s/mr-%d-%d", AWS_INTERMEDIATE_PREFIX, i, j))
		}
	}
	return intermediateFiles
}

func buildOutputFiles(testCoordinatorInput TestCoordinatorInput) []string {
	outputFiles := []string{}
	for i := 0; i < testCoordinatorInput.nReduce; i++ {
		outputFiles = append(
			outputFiles,
			fmt.Sprintf("%s/mr-out-%d", AWS_OUTPUT_PREFIX, i))
	}
	return outputFiles
}

func checkAndDeleteFilesInS3(prefix string, filenames []string, t *testing.T) {
	objects, err := ListFilesInS3(prefix)
	if err != nil {
		t.Errorf("Error listing contents in S3 %v", err)
		return
	}
	contentSet := map[string]bool{}
	for _, content := range objects.Contents {
		contentSet[*content.Key] = true
	}
	for _, filename := range filenames {
		if _, ok := contentSet[filename]; !ok {
			t.Errorf("Expected %v file to exist on AWS", filename)
		}
		DeleteFileInS3(filename)
	}
}

func TestWorkerCoordinatorCompletesMapTask(t *testing.T) {
	setup()
	expectedIntermediateFilenames := buildIntermediateFiles(simpleTestInput)
	t.Run(simpleTestInput.name(), func(t *testing.T) {
		c := MakeCoordinator(simpleTestInput.files, simpleTestInput.nReduce)
		go func() {
			WorkerInternal(CountMap, CountReduce, WorkerCrash{}, /* changeSeed= */ false)
		}()
		for {
			if c.state == COORDINATOR_REDUCE {
				break
			}
			time.Sleep(500 * time.Millisecond)
		}
		c.Stop()
		checkAndDeleteFilesInS3(AWS_INTERMEDIATE_PREFIX, expectedIntermediateFilenames, t)
	})
}

func TestWorkerCoordinatorOneWorkerCompletesMapAndReduceTask(t *testing.T) {
	setup()
	expectedIntermediateFilenames := buildIntermediateFiles(simpleTestInput)
	expectedOutputFilenames := buildOutputFiles(simpleTestInput)
	t.Run(simpleTestInput.name(), func(t *testing.T) {
		MakeCoordinator(simpleTestInput.files, simpleTestInput.nReduce)
		done := make(chan bool)
		go func() {
			WorkerInternal(CountMap, CountReduce, WorkerCrash{}, /* changeSeed= */ false)
			done<-true
		}()
		<-done
		checkAndDeleteFilesInS3(AWS_INTERMEDIATE_PREFIX, expectedIntermediateFilenames, t)
		checkAndDeleteFilesInS3(AWS_OUTPUT_PREFIX, expectedOutputFilenames, t)
	})
}

// func TestWorkerCoordinatorTwoWorkersCompletesMapAndReduceTask(t *testing.T) {
// 	setup()
// 	expectedIntermediateFilenames := buildIntermediateFiles(complexTestInput)
// 	expectedOutputFilenames := buildOutputFiles(complexTestInput)
// 	t.Run(complexTestInput.name(), func(t *testing.T) {
// 		MakeCoordinator(complexTestInput.files, complexTestInput.nReduce)
// 		doneOne := make(chan bool)
// 		doneTwo := make(chan bool)
// 		go func() {
// 			Worker(CountMap, CountReduce)
// 			doneOne<-true
// 		}()
// 		go func() {
// 			Worker(CountMap, CountReduce)
// 			doneTwo<-true
// 		}()
// 		<-doneOne
// 		<-doneTwo
// 		checkFilesExist(expectedIntermediateFilenames)
// 		removeFiles(expectedIntermediateFilenames)
// 		checkFilesExist(expectedOutputFilenames)
// 		removeFiles(expectedOutputFilenames)
// 	})
// }

// func TestWorkerCoordinatorLabConditions(t *testing.T) {
// 	setup()
// 	expectedIntermediateFilenames := buildIntermediateFiles(labTestInput)
// 	expectedOutputFilenames := buildOutputFiles(labTestInput)
// 	t.Run(labTestInput.name(), func(t *testing.T) {
// 		MakeCoordinator(labTestInput.files, labTestInput.nReduce)
// 		doneOne := make(chan bool)
// 		doneTwo := make(chan bool)
// 		doneThree := make(chan bool)
// 		go func() {
// 			Worker(CountMap, CountReduce)
// 			doneOne<-true
// 		}()
// 		go func() {
// 			Worker(CountMap, CountReduce)
// 			doneTwo<-true
// 		}()
// 		go func() {
// 			Worker(CountMap, CountReduce)
// 			doneThree<-true
// 		}()
// 		<-doneOne
// 		<-doneTwo
// 		<-doneThree
// 		checkFilesExist(expectedIntermediateFilenames)
// 		removeFiles(expectedIntermediateFilenames)
// 		checkFilesExist(expectedOutputFilenames)
// 		removeFiles(expectedOutputFilenames)
// 	})
// }





